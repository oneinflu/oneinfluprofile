{"version":3,"sources":["../../../../node_modules/react-aria-components/dist/packages/react-aria-components/src/OverlayArrow.tsx","../../../../node_modules/%40react-aria/overlays/dist/packages/%40react-aria/overlays/src/PortalProvider.tsx","../../../../node_modules/%40react-aria/overlays/dist/calculatePosition.mjs","../../../../node_modules/%40react-aria/overlays/dist/useCloseOnScroll.mjs","../../../../node_modules/%40react-aria/utils/dist/useResizeObserver.mjs","../../../../node_modules/%40react-aria/overlays/dist/useOverlayPosition.mjs","../../../../node_modules/%40react-aria/utils/dist/animation.mjs","../../../../node_modules/%40react-stately/overlays/dist/useOverlayTriggerState.mjs"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  ClassNameOrFunction,\n  ContextValue,\n  RenderProps,\n  useContextProps,\n  useRenderProps\n} from './utils';\nimport {DOMProps, forwardRefType} from '@react-types/shared';\nimport {filterDOMProps} from '@react-aria/utils';\nimport {PlacementAxis} from 'react-aria';\nimport React, {createContext, CSSProperties, ForwardedRef, forwardRef, HTMLAttributes} from 'react';\n\ninterface OverlayArrowContextValue extends OverlayArrowProps {\n  placement: PlacementAxis | null\n}\n\nexport const OverlayArrowContext = createContext<ContextValue<OverlayArrowContextValue, HTMLDivElement>>({\n  placement: 'bottom'\n});\n\nexport interface OverlayArrowProps extends Omit<HTMLAttributes<HTMLDivElement>, 'className' | 'style' | 'children'>, RenderProps<OverlayArrowRenderProps>, DOMProps {\n  /**\n   * The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. A function may be provided to compute the class based on component state.\n   * @default 'react-aria-OverlayArrow'\n   */\n  className?: ClassNameOrFunction<OverlayArrowRenderProps>\n}\n\nexport interface OverlayArrowRenderProps {\n  /**\n   * The placement of the overlay relative to the trigger.\n   * @selector [data-placement=\"left | right | top | bottom\"]\n   */\n  placement: PlacementAxis | null\n}\n\n/**\n * An OverlayArrow renders a custom arrow element relative to an overlay element\n * such as a popover or tooltip such that it aligns with a trigger element.\n */\nexport const OverlayArrow = /*#__PURE__*/ (forwardRef as forwardRefType)(function OverlayArrow(props: OverlayArrowProps, ref: ForwardedRef<HTMLDivElement>) {\n  [props, ref] = useContextProps(props, ref, OverlayArrowContext);\n  let placement = (props as OverlayArrowContextValue).placement;\n  let style: CSSProperties = {\n    position: 'absolute',\n    transform: placement === 'top' || placement === 'bottom' ? 'translateX(-50%)' : 'translateY(-50%)'\n  };\n  if (placement != null) {\n    style[placement] = '100%';\n  }\n\n  let renderProps = useRenderProps({\n    ...props,\n    defaultClassName: 'react-aria-OverlayArrow',\n    values: {\n      placement\n    }\n  });\n  // remove undefined values from renderProps.style object so that it can be\n  // spread merged with the other style object\n  if (renderProps.style) {\n    Object.keys(renderProps.style).forEach(key => renderProps.style![key] === undefined && delete renderProps.style![key]);\n  }\n\n  let DOMProps = filterDOMProps(props);\n\n  return (\n    <div\n      {...DOMProps}\n      {...renderProps}\n      style={{\n        ...style,\n        ...renderProps.style\n      }}\n      ref={ref}\n      data-placement={placement} />\n  );\n});\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React, {createContext, JSX, ReactNode, useContext} from 'react';\n\nexport interface PortalProviderProps {\n  /** Should return the element where we should portal to. Can clear the context by passing null. */\n  getContainer?: (() => HTMLElement | null) | null,\n  /** The content of the PortalProvider. Should contain all children that want to portal their overlays to the element returned by the provided `getContainer()`. */\n  children: ReactNode\n}\n\nexport interface PortalProviderContextValue extends Omit<PortalProviderProps, 'children'>{};\n\nexport const PortalContext: React.Context<PortalProviderContextValue> = createContext<PortalProviderContextValue>({});\n\n/**\n * Sets the portal container for all overlay elements rendered by its children.\n */\nexport function UNSAFE_PortalProvider(props: PortalProviderProps): JSX.Element {\n  let {getContainer} = props;\n  let {getContainer: ctxGetContainer} = useUNSAFE_PortalContext();\n  return (\n    <PortalContext.Provider value={{getContainer: getContainer === null ? undefined : getContainer ?? ctxGetContainer}}>\n      {props.children}\n    </PortalContext.Provider>\n  );\n}\n\nexport function useUNSAFE_PortalContext(): PortalProviderContextValue {\n  return useContext(PortalContext) ?? {};\n}\n","import {isWebKit as $fZVmS$isWebKit, clamp as $fZVmS$clamp} from \"@react-aria/utils\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $edcf132a9284368a$var$AXIS = {\n    top: 'top',\n    bottom: 'top',\n    left: 'left',\n    right: 'left'\n};\nconst $edcf132a9284368a$var$FLIPPED_DIRECTION = {\n    top: 'bottom',\n    bottom: 'top',\n    left: 'right',\n    right: 'left'\n};\nconst $edcf132a9284368a$var$CROSS_AXIS = {\n    top: 'left',\n    left: 'top'\n};\nconst $edcf132a9284368a$var$AXIS_SIZE = {\n    top: 'height',\n    left: 'width'\n};\nconst $edcf132a9284368a$var$TOTAL_SIZE = {\n    width: 'totalWidth',\n    height: 'totalHeight'\n};\nconst $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE = {};\nlet $edcf132a9284368a$var$getVisualViewport = ()=>typeof document !== 'undefined' ? window.visualViewport : null;\nfunction $edcf132a9284368a$var$getContainerDimensions(containerNode, visualViewport) {\n    let width = 0, height = 0, totalWidth = 0, totalHeight = 0, top = 0, left = 0;\n    let scroll = {};\n    var _visualViewport_scale;\n    let isPinchZoomedIn = ((_visualViewport_scale = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.scale) !== null && _visualViewport_scale !== void 0 ? _visualViewport_scale : 1) > 1;\n    // In the case where the container is `html` or `body` and the container doesn't have something like `position: relative`,\n    // then position absolute will be positioned relative to the viewport, also known as the `initial containing block`.\n    // That's why we use the visual viewport instead.\n    if (containerNode.tagName === 'BODY' || containerNode.tagName === 'HTML') {\n        let documentElement = document.documentElement;\n        totalWidth = documentElement.clientWidth;\n        totalHeight = documentElement.clientHeight;\n        var _visualViewport_width;\n        width = (_visualViewport_width = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : totalWidth;\n        var _visualViewport_height;\n        height = (_visualViewport_height = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : totalHeight;\n        scroll.top = documentElement.scrollTop || containerNode.scrollTop;\n        scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;\n        // The goal of the below is to get a top/left value that represents the top/left of the visual viewport with\n        // respect to the layout viewport origin. This combined with the scrollTop/scrollLeft will allow us to calculate\n        // coordinates/values with respect to the visual viewport or with respect to the layout viewport.\n        if (visualViewport) {\n            top = visualViewport.offsetTop;\n            left = visualViewport.offsetLeft;\n        }\n    } else {\n        ({ width: width, height: height, top: top, left: left } = $edcf132a9284368a$var$getOffset(containerNode, false));\n        scroll.top = containerNode.scrollTop;\n        scroll.left = containerNode.scrollLeft;\n        totalWidth = width;\n        totalHeight = height;\n    }\n    if ((0, $fZVmS$isWebKit)() && (containerNode.tagName === 'BODY' || containerNode.tagName === 'HTML') && isPinchZoomedIn) {\n        // Safari will report a non-zero scrollTop/Left for the non-scrolling body/HTML element when pinch zoomed in unlike other browsers.\n        // Set to zero for parity calculations so we get consistent positioning of overlays across all browsers.\n        // Also switch to visualViewport.pageTop/pageLeft so that we still accomodate for scroll positioning for body/HTML elements that are actually scrollable\n        // before pinch zoom happens\n        scroll.top = 0;\n        scroll.left = 0;\n        var _visualViewport_pageTop;\n        top = (_visualViewport_pageTop = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.pageTop) !== null && _visualViewport_pageTop !== void 0 ? _visualViewport_pageTop : 0;\n        var _visualViewport_pageLeft;\n        left = (_visualViewport_pageLeft = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.pageLeft) !== null && _visualViewport_pageLeft !== void 0 ? _visualViewport_pageLeft : 0;\n    }\n    return {\n        width: width,\n        height: height,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight,\n        scroll: scroll,\n        top: top,\n        left: left\n    };\n}\nfunction $edcf132a9284368a$var$getScroll(node) {\n    return {\n        top: node.scrollTop,\n        left: node.scrollLeft,\n        width: node.scrollWidth,\n        height: node.scrollHeight\n    };\n}\n// Determines the amount of space required when moving the overlay to ensure it remains in the boundary\nfunction $edcf132a9284368a$var$getDelta(axis, offset, size, // The dimensions of the boundary element that the popover is\n// positioned within (most of the time this is the <body>).\nboundaryDimensions, // The dimensions of the containing block element that the popover is\n// positioned relative to (e.g. parent with position: relative).\n// Usually this is the same as the boundary element, but if the popover\n// is portaled somewhere other than the body and has an ancestor with\n// position: relative/absolute, it will be different.\ncontainerDimensions, padding, containerOffsetWithBoundary) {\n    var _containerDimensions_scroll_axis;\n    let containerScroll = (_containerDimensions_scroll_axis = containerDimensions.scroll[axis]) !== null && _containerDimensions_scroll_axis !== void 0 ? _containerDimensions_scroll_axis : 0;\n    // The height/width of the boundary. Matches the axis along which we are adjusting the overlay position\n    let boundarySize = boundaryDimensions[$edcf132a9284368a$var$AXIS_SIZE[axis]];\n    // Calculate the edges of the boundary (accomodating for the boundary padding) and the edges of the overlay.\n    // Note that these values are with respect to the visual viewport (aka 0,0 is the top left of the viewport)\n    let boundaryStartEdge = containerOffsetWithBoundary[axis] + boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] + padding;\n    let boundaryEndEdge = containerOffsetWithBoundary[axis] + boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] + boundarySize - padding;\n    // transformed value of the left edge of the overlay\n    let startEdgeOffset = offset - containerScroll + boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];\n    // transformed value of the right edge of the overlay\n    let endEdgeOffset = offset - containerScroll + size + boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];\n    // If any of the overlay edges falls outside of the boundary, shift the overlay the required amount to align one of the overlay's\n    // edges with the closest boundary edge.\n    if (startEdgeOffset < boundaryStartEdge) return boundaryStartEdge - startEdgeOffset;\n    else if (endEdgeOffset > boundaryEndEdge) return Math.max(boundaryEndEdge - endEdgeOffset, boundaryStartEdge - startEdgeOffset);\n    else return 0;\n}\nfunction $edcf132a9284368a$var$getMargins(node) {\n    let style = window.getComputedStyle(node);\n    return {\n        top: parseInt(style.marginTop, 10) || 0,\n        bottom: parseInt(style.marginBottom, 10) || 0,\n        left: parseInt(style.marginLeft, 10) || 0,\n        right: parseInt(style.marginRight, 10) || 0\n    };\n}\nfunction $edcf132a9284368a$var$parsePlacement(input) {\n    if ($edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input]) return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n    let [placement, crossPlacement] = input.split(' ');\n    let axis = $edcf132a9284368a$var$AXIS[placement] || 'right';\n    let crossAxis = $edcf132a9284368a$var$CROSS_AXIS[axis];\n    if (!$edcf132a9284368a$var$AXIS[crossPlacement]) crossPlacement = 'center';\n    let size = $edcf132a9284368a$var$AXIS_SIZE[axis];\n    let crossSize = $edcf132a9284368a$var$AXIS_SIZE[crossAxis];\n    $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input] = {\n        placement: placement,\n        crossPlacement: crossPlacement,\n        axis: axis,\n        crossAxis: crossAxis,\n        size: size,\n        crossSize: crossSize\n    };\n    return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n}\nfunction $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset, containerDimensions) {\n    let { placement: placement, crossPlacement: crossPlacement, axis: axis, crossAxis: crossAxis, size: size, crossSize: crossSize } = placementInfo;\n    let position = {};\n    var _childOffset_crossAxis;\n    // button position\n    position[crossAxis] = (_childOffset_crossAxis = childOffset[crossAxis]) !== null && _childOffset_crossAxis !== void 0 ? _childOffset_crossAxis : 0;\n    var _childOffset_crossSize, _overlaySize_crossSize, _childOffset_crossSize1, _overlaySize_crossSize1;\n    if (crossPlacement === 'center') //  + (button size / 2) - (overlay size / 2)\n    // at this point the overlay center should match the button center\n    position[crossAxis] += (((_childOffset_crossSize = childOffset[crossSize]) !== null && _childOffset_crossSize !== void 0 ? _childOffset_crossSize : 0) - ((_overlaySize_crossSize = overlaySize[crossSize]) !== null && _overlaySize_crossSize !== void 0 ? _overlaySize_crossSize : 0)) / 2;\n    else if (crossPlacement !== crossAxis) //  + (button size) - (overlay size)\n    // at this point the overlay bottom should match the button bottom\n    position[crossAxis] += ((_childOffset_crossSize1 = childOffset[crossSize]) !== null && _childOffset_crossSize1 !== void 0 ? _childOffset_crossSize1 : 0) - ((_overlaySize_crossSize1 = overlaySize[crossSize]) !== null && _overlaySize_crossSize1 !== void 0 ? _overlaySize_crossSize1 : 0);\n     /* else {\n    the overlay top should match the button top\n  } */ \n    position[crossAxis] += crossOffset;\n    // overlay top or left overlapping arrow with button bottom or right\n    const minPosition = childOffset[crossAxis] - overlaySize[crossSize] + arrowSize + arrowBoundaryOffset;\n    // overlay bottom or right overlapping arrow with button top or left\n    const maxPosition = childOffset[crossAxis] + childOffset[crossSize] - arrowSize - arrowBoundaryOffset;\n    position[crossAxis] = (0, $fZVmS$clamp)(position[crossAxis], minPosition, maxPosition);\n    // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.\n    if (placement === axis) {\n        // If the container is positioned (non-static), then we use the container's actual\n        // height, as `bottom` will be relative to this height.  But if the container is static,\n        // then it can only be the `document.body`, and `bottom` will be relative to _its_\n        // container.\n        let containerHeight = isContainerPositioned ? containerDimensions[size] : containerDimensions[$edcf132a9284368a$var$TOTAL_SIZE[size]];\n        position[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);\n    } else position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n    return position;\n}\nfunction $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlayHeight, heightGrowthDirection, containerDimensions, isContainerDescendentOfBoundary, visualViewport) {\n    var _position_bottom, _containerDimensions_scroll_top;\n    // For cases where position is set via \"bottom\" instead of \"top\", we need to calculate the true overlay top\n    // with respect to the container.\n    let overlayTop = (position.top != null ? position.top : containerDimensions[$edcf132a9284368a$var$TOTAL_SIZE.height] - ((_position_bottom = position.bottom) !== null && _position_bottom !== void 0 ? _position_bottom : 0) - overlayHeight) - ((_containerDimensions_scroll_top = containerDimensions.scroll.top) !== null && _containerDimensions_scroll_top !== void 0 ? _containerDimensions_scroll_top : 0);\n    // calculate the dimentions of the \"boundingRect\" which is most restrictive top/bottom of the boundaryRect and the visual view port\n    let boundaryToContainerTransformOffset = isContainerDescendentOfBoundary ? containerOffsetWithBoundary.top : 0;\n    var _visualViewport_offsetTop, _visualViewport_offsetTop1, _visualViewport_height;\n    let boundingRect = {\n        // This should be boundary top in container coord system vs viewport top in container coord system\n        // For the viewport top, there are several cases\n        // 1. pinchzoom case where we want the viewports offset top as top here\n        // 2. case where container is offset from the boundary and is contained by the boundary. In this case the top we want here is NOT 0, we want to take boundary's top even though is is a negative number OR the visual viewport, whichever is more restrictive\n        top: Math.max(boundaryDimensions.top + boundaryToContainerTransformOffset, ((_visualViewport_offsetTop = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.offsetTop) !== null && _visualViewport_offsetTop !== void 0 ? _visualViewport_offsetTop : boundaryDimensions.top) + boundaryToContainerTransformOffset),\n        bottom: Math.min(boundaryDimensions.top + boundaryDimensions.height + boundaryToContainerTransformOffset, ((_visualViewport_offsetTop1 = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.offsetTop) !== null && _visualViewport_offsetTop1 !== void 0 ? _visualViewport_offsetTop1 : 0) + ((_visualViewport_height = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : 0))\n    };\n    var _margins_top, _margins_bottom, _margins_top1, _margins_bottom1;\n    let maxHeight = heightGrowthDirection !== 'top' ? // We want the distance between the top of the overlay to the bottom of the boundary\n    Math.max(0, boundingRect.bottom // this is the bottom of the boundary\n     - overlayTop // this is the top of the overlay\n     - (((_margins_top = margins.top) !== null && _margins_top !== void 0 ? _margins_top : 0) + ((_margins_bottom = margins.bottom) !== null && _margins_bottom !== void 0 ? _margins_bottom : 0) + padding // save additional space for margin and padding\n    )) : Math.max(0, overlayTop + overlayHeight // this is the bottom of the overlay\n     - boundingRect.top // this is the top of the boundary\n     - (((_margins_top1 = margins.top) !== null && _margins_top1 !== void 0 ? _margins_top1 : 0) + ((_margins_bottom1 = margins.bottom) !== null && _margins_bottom1 !== void 0 ? _margins_bottom1 : 0) + padding // save additional space for margin and padding\n    ));\n    return maxHeight;\n}\nfunction $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo, containerDimensions, isContainerDescendentOfBoundary) {\n    let { placement: placement, axis: axis, size: size } = placementInfo;\n    var _containerDimensions_scroll_axis, _margins_axis;\n    if (placement === axis) return Math.max(0, childOffset[axis] // trigger start\n     - ((_containerDimensions_scroll_axis = containerDimensions.scroll[axis]) !== null && _containerDimensions_scroll_axis !== void 0 ? _containerDimensions_scroll_axis : 0 // transform trigger position to be with respect to viewport 0,0\n    ) - (boundaryDimensions[axis] + (isContainerDescendentOfBoundary ? containerOffsetWithBoundary[axis] : 0) // boundary start\n    ) - ((_margins_axis = margins[axis]) !== null && _margins_axis !== void 0 ? _margins_axis : 0 // margins usually for arrows or other decorations\n    ) - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding); // padding between overlay and boundary\n    var _containerDimensions_scroll_axis1, _margins_axis1;\n    return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + (isContainerDescendentOfBoundary ? containerOffsetWithBoundary[axis] : 0) - childOffset[axis] - childOffset[size] + ((_containerDimensions_scroll_axis1 = containerDimensions.scroll[axis]) !== null && _containerDimensions_scroll_axis1 !== void 0 ? _containerDimensions_scroll_axis1 : 0) - ((_margins_axis1 = margins[axis]) !== null && _margins_axis1 !== void 0 ? _margins_axis1 : 0) - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);\n}\nfunction $edcf132a9284368a$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight, arrowSize, arrowBoundaryOffset, isContainerDescendentOfBoundary, visualViewport) {\n    let placementInfo = $edcf132a9284368a$var$parsePlacement(placementInput);\n    let { size: size, crossAxis: crossAxis, crossSize: crossSize, placement: placement, crossPlacement: crossPlacement } = placementInfo;\n    let position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset, containerDimensions);\n    let normalizedOffset = offset;\n    let space = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo, containerDimensions, isContainerDescendentOfBoundary);\n    // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip\n    if (flip && overlaySize[size] > space) {\n        let flippedPlacementInfo = $edcf132a9284368a$var$parsePlacement(`${$edcf132a9284368a$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);\n        let flippedPosition = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset, containerDimensions);\n        let flippedSpace = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo, containerDimensions, isContainerDescendentOfBoundary);\n        // If the available space for the flipped position is greater than the original available space, flip.\n        if (flippedSpace > space) {\n            placementInfo = flippedPlacementInfo;\n            position = flippedPosition;\n            normalizedOffset = offset;\n        }\n    }\n    // Determine the direction the height of the overlay can grow so that we can choose how to calculate the max height\n    let heightGrowthDirection = 'bottom';\n    if (placementInfo.axis === 'top') {\n        if (placementInfo.placement === 'top') heightGrowthDirection = 'top';\n        else if (placementInfo.placement === 'bottom') heightGrowthDirection = 'bottom';\n    } else if (placementInfo.crossAxis === 'top') {\n        if (placementInfo.crossPlacement === 'top') heightGrowthDirection = 'bottom';\n        else if (placementInfo.crossPlacement === 'bottom') heightGrowthDirection = 'top';\n    }\n    let delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);\n    position[crossAxis] += delta;\n    let maxHeight = $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlaySize.height, heightGrowthDirection, containerDimensions, isContainerDescendentOfBoundary, visualViewport);\n    if (userSetMaxHeight && userSetMaxHeight < maxHeight) maxHeight = userSetMaxHeight;\n    overlaySize.height = Math.min(overlaySize.height, maxHeight);\n    position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset, containerDimensions);\n    delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);\n    position[crossAxis] += delta;\n    let arrowPosition = {};\n    // All values are transformed so that 0 is at the top/left of the overlay depending on the orientation\n    // Prefer the arrow being in the center of the trigger/overlay anchor element\n    // childOffset[crossAxis] + .5 * childOffset[crossSize] = absolute position with respect to the trigger's coordinate system that would place the arrow in the center of the trigger\n    // position[crossAxis] - margins[AXIS[crossAxis]] = value use to transform the position to a value with respect to the overlay's coordinate system. A child element's (aka arrow) position absolute's \"0\"\n    // is positioned after the margin of its parent (aka overlay) so we need to subtract it to get the proper coordinate transform\n    let origin = childOffset[crossAxis] - position[crossAxis] - margins[$edcf132a9284368a$var$AXIS[crossAxis]];\n    let preferredArrowPosition = origin + .5 * childOffset[crossSize];\n    // Min/Max position limits for the arrow with respect to the overlay\n    const arrowMinPosition = arrowSize / 2 + arrowBoundaryOffset;\n    var _margins_left, _margins_right, _margins_top, _margins_bottom;\n    // overlaySize[crossSize] - margins = true size of the overlay\n    const overlayMargin = $edcf132a9284368a$var$AXIS[crossAxis] === 'left' ? ((_margins_left = margins.left) !== null && _margins_left !== void 0 ? _margins_left : 0) + ((_margins_right = margins.right) !== null && _margins_right !== void 0 ? _margins_right : 0) : ((_margins_top = margins.top) !== null && _margins_top !== void 0 ? _margins_top : 0) + ((_margins_bottom = margins.bottom) !== null && _margins_bottom !== void 0 ? _margins_bottom : 0);\n    const arrowMaxPosition = overlaySize[crossSize] - overlayMargin - arrowSize / 2 - arrowBoundaryOffset;\n    // Min/Max position limits for the arrow with respect to the trigger/overlay anchor element\n    // Same margin accomodation done here as well as for the preferredArrowPosition\n    const arrowOverlappingChildMinEdge = childOffset[crossAxis] + arrowSize / 2 - (position[crossAxis] + margins[$edcf132a9284368a$var$AXIS[crossAxis]]);\n    const arrowOverlappingChildMaxEdge = childOffset[crossAxis] + childOffset[crossSize] - arrowSize / 2 - (position[crossAxis] + margins[$edcf132a9284368a$var$AXIS[crossAxis]]);\n    // Clamp the arrow positioning so that it always is within the bounds of the anchor and the overlay\n    const arrowPositionOverlappingChild = (0, $fZVmS$clamp)(preferredArrowPosition, arrowOverlappingChildMinEdge, arrowOverlappingChildMaxEdge);\n    arrowPosition[crossAxis] = (0, $fZVmS$clamp)(arrowPositionOverlappingChild, arrowMinPosition, arrowMaxPosition);\n    // If there is an arrow, use that as the origin so that animations are smooth.\n    // Otherwise use the target edge.\n    ({ placement: placement, crossPlacement: crossPlacement } = placementInfo);\n    if (arrowSize) origin = arrowPosition[crossAxis];\n    else if (crossPlacement === 'right') origin += childOffset[crossSize];\n    else if (crossPlacement === 'center') origin += childOffset[crossSize] / 2;\n    let crossOrigin = placement === 'left' || placement === 'top' ? overlaySize[size] : 0;\n    let triggerAnchorPoint = {\n        x: placement === 'top' || placement === 'bottom' ? origin : crossOrigin,\n        y: placement === 'left' || placement === 'right' ? origin : crossOrigin\n    };\n    return {\n        position: position,\n        maxHeight: maxHeight,\n        arrowOffsetLeft: arrowPosition.left,\n        arrowOffsetTop: arrowPosition.top,\n        placement: placement,\n        triggerAnchorPoint: triggerAnchorPoint\n    };\n}\nfunction $edcf132a9284368a$export$b3ceb0cbf1056d98(opts) {\n    let { placement: placement, targetNode: targetNode, overlayNode: overlayNode, scrollNode: scrollNode, padding: padding, shouldFlip: shouldFlip, boundaryElement: boundaryElement, offset: offset, crossOffset: crossOffset, maxHeight: maxHeight, arrowSize: arrowSize = 0, arrowBoundaryOffset: arrowBoundaryOffset = 0 } = opts;\n    let visualViewport = $edcf132a9284368a$var$getVisualViewport();\n    let container = overlayNode instanceof HTMLElement ? $edcf132a9284368a$var$getContainingBlock(overlayNode) : document.documentElement;\n    let isViewportContainer = container === document.documentElement;\n    const containerPositionStyle = window.getComputedStyle(container).position;\n    let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';\n    let childOffset = isViewportContainer ? $edcf132a9284368a$var$getOffset(targetNode, false) : $edcf132a9284368a$var$getPosition(targetNode, container, false);\n    if (!isViewportContainer) {\n        let { marginTop: marginTop, marginLeft: marginLeft } = window.getComputedStyle(targetNode);\n        childOffset.top += parseInt(marginTop, 10) || 0;\n        childOffset.left += parseInt(marginLeft, 10) || 0;\n    }\n    let overlaySize = $edcf132a9284368a$var$getOffset(overlayNode, true);\n    let margins = $edcf132a9284368a$var$getMargins(overlayNode);\n    var _margins_left, _margins_right;\n    overlaySize.width += ((_margins_left = margins.left) !== null && _margins_left !== void 0 ? _margins_left : 0) + ((_margins_right = margins.right) !== null && _margins_right !== void 0 ? _margins_right : 0);\n    var _margins_top, _margins_bottom;\n    overlaySize.height += ((_margins_top = margins.top) !== null && _margins_top !== void 0 ? _margins_top : 0) + ((_margins_bottom = margins.bottom) !== null && _margins_bottom !== void 0 ? _margins_bottom : 0);\n    let scrollSize = $edcf132a9284368a$var$getScroll(scrollNode);\n    // Note that due to logic inside getContainerDimensions, for cases where the boundary element is the body, we will return\n    // a height/width that matches the visual viewport size rather than the body's height/width (aka for zoom it will be zoom adjusted size)\n    // and a top/left that is adjusted as well (will return the top/left of the zoomed in viewport, or 0,0 for a non-zoomed body)\n    // Otherwise this returns the height/width of a arbitrary boundary element, and its top/left with respect to the viewport (NOTE THIS MEANS IT DOESNT INCLUDE SCROLL)\n    let boundaryDimensions = $edcf132a9284368a$var$getContainerDimensions(boundaryElement, visualViewport);\n    let containerDimensions = $edcf132a9284368a$var$getContainerDimensions(container, visualViewport);\n    // If the container is the HTML element wrapping the body element, the retrieved scrollTop/scrollLeft will be equal to the\n    // body element's scroll. Set the container's scroll values to 0 since the overlay's edge position value in getDelta don't then need to be further offset\n    // by the container scroll since they are essentially the same containing element and thus in the same coordinate system\n    let containerOffsetWithBoundary = $edcf132a9284368a$var$getPosition(boundaryElement, container, false);\n    let isContainerDescendentOfBoundary = boundaryElement.contains(container);\n    return $edcf132a9284368a$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight, arrowSize, arrowBoundaryOffset, isContainerDescendentOfBoundary, visualViewport);\n}\nfunction $edcf132a9284368a$export$4b834cebd9e5cebe(node, ignoreScale) {\n    let { top: top, left: left, width: width, height: height } = node.getBoundingClientRect();\n    // Use offsetWidth and offsetHeight if this is an HTML element, so that\n    // the size is not affected by scale transforms.\n    if (ignoreScale && node instanceof node.ownerDocument.defaultView.HTMLElement) {\n        width = node.offsetWidth;\n        height = node.offsetHeight;\n    }\n    return {\n        top: top,\n        left: left,\n        width: width,\n        height: height\n    };\n}\nfunction $edcf132a9284368a$var$getOffset(node, ignoreScale) {\n    let { top: top, left: left, width: width, height: height } = $edcf132a9284368a$export$4b834cebd9e5cebe(node, ignoreScale);\n    let { scrollTop: scrollTop, scrollLeft: scrollLeft, clientTop: clientTop, clientLeft: clientLeft } = document.documentElement;\n    return {\n        top: top + scrollTop - clientTop,\n        left: left + scrollLeft - clientLeft,\n        width: width,\n        height: height\n    };\n}\nfunction $edcf132a9284368a$var$getPosition(node, parent, ignoreScale) {\n    let style = window.getComputedStyle(node);\n    let offset;\n    if (style.position === 'fixed') offset = $edcf132a9284368a$export$4b834cebd9e5cebe(node, ignoreScale);\n    else {\n        offset = $edcf132a9284368a$var$getOffset(node, ignoreScale);\n        let parentOffset = $edcf132a9284368a$var$getOffset(parent, ignoreScale);\n        let parentStyle = window.getComputedStyle(parent);\n        parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;\n        parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;\n        offset.top -= parentOffset.top;\n        offset.left -= parentOffset.left;\n    }\n    offset.top -= parseInt(style.marginTop, 10) || 0;\n    offset.left -= parseInt(style.marginLeft, 10) || 0;\n    return offset;\n}\n// Returns the containing block of an element, which is the element that\n// this element will be positioned relative to.\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\nfunction $edcf132a9284368a$var$getContainingBlock(node) {\n    // The offsetParent of an element in most cases equals the containing block.\n    // https://w3c.github.io/csswg-drafts/cssom-view/#dom-htmlelement-offsetparent\n    let offsetParent = node.offsetParent;\n    // The offsetParent algorithm terminates at the document body,\n    // even if the body is not a containing block. Double check that\n    // and use the documentElement if so.\n    if (offsetParent && offsetParent === document.body && window.getComputedStyle(offsetParent).position === 'static' && !$edcf132a9284368a$var$isContainingBlock(offsetParent)) offsetParent = document.documentElement;\n    // TODO(later): handle table elements?\n    // The offsetParent can be null if the element has position: fixed, or a few other cases.\n    // We have to walk up the tree manually in this case because fixed positioned elements\n    // are still positioned relative to their containing block, which is not always the viewport.\n    if (offsetParent == null) {\n        offsetParent = node.parentElement;\n        while(offsetParent && !$edcf132a9284368a$var$isContainingBlock(offsetParent))offsetParent = offsetParent.parentElement;\n    }\n    // Fall back to the viewport.\n    return offsetParent || document.documentElement;\n}\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\nfunction $edcf132a9284368a$var$isContainingBlock(node) {\n    let style = window.getComputedStyle(node);\n    return style.transform !== 'none' || /transform|perspective/.test(style.willChange) || style.filter !== 'none' || style.contain === 'paint' || 'backdropFilter' in style && style.backdropFilter !== 'none' || 'WebkitBackdropFilter' in style && style.WebkitBackdropFilter !== 'none';\n}\n\n\nexport {$edcf132a9284368a$export$6839422d1f33cee9 as calculatePositionInternal, $edcf132a9284368a$export$b3ceb0cbf1056d98 as calculatePosition, $edcf132a9284368a$export$4b834cebd9e5cebe as getRect};\n//# sourceMappingURL=calculatePosition.module.js.map\n","import {useEffect as $dRVb8$useEffect} from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $dd149f63282afbbf$export$f6211563215e3b37 = new WeakMap();\nfunction $dd149f63282afbbf$export$18fc8428861184da(opts) {\n    let { triggerRef: triggerRef, isOpen: isOpen, onClose: onClose } = opts;\n    (0, $dRVb8$useEffect)(()=>{\n        if (!isOpen || onClose === null) return;\n        let onScroll = (e)=>{\n            // Ignore if scrolling an scrollable region outside the trigger's tree.\n            let target = e.target;\n            // window is not a Node and doesn't have contain, but window contains everything\n            if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current)) return;\n            // Ignore scroll events on any input or textarea as the cursor position can cause it to scroll\n            // such as in a combobox. Clicking the dropdown button places focus on the input, and if the\n            // text inside the input extends beyond the 'end', then it will scroll so the cursor is visible at the end.\n            if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;\n            let onCloseHandler = onClose || $dd149f63282afbbf$export$f6211563215e3b37.get(triggerRef.current);\n            if (onCloseHandler) onCloseHandler();\n        };\n        window.addEventListener('scroll', onScroll, true);\n        return ()=>{\n            window.removeEventListener('scroll', onScroll, true);\n        };\n    }, [\n        isOpen,\n        onClose,\n        triggerRef\n    ]);\n}\n\n\nexport {$dd149f63282afbbf$export$f6211563215e3b37 as onCloseMap, $dd149f63282afbbf$export$18fc8428861184da as useCloseOnScroll};\n//# sourceMappingURL=useCloseOnScroll.module.js.map\n","import {useEffectEvent as $8ae05eaa5c114e9c$export$7f54fc3180508a52} from \"./useEffectEvent.mjs\";\nimport {useEffect as $Vsl8o$useEffect} from \"react\";\n\n\n\nfunction $9daab02d461809db$var$hasResizeObserver() {\n    return typeof window.ResizeObserver !== 'undefined';\n}\nfunction $9daab02d461809db$export$683480f191c0e3ea(options) {\n    // Only call onResize from inside the effect, otherwise we'll void our assumption that\n    // useEffectEvents are safe to pass in.\n    const { ref: ref, box: box, onResize: onResize } = options;\n    let onResizeEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(onResize);\n    (0, $Vsl8o$useEffect)(()=>{\n        let element = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!element) return;\n        if (!$9daab02d461809db$var$hasResizeObserver()) {\n            window.addEventListener('resize', onResizeEvent, false);\n            return ()=>{\n                window.removeEventListener('resize', onResizeEvent, false);\n            };\n        } else {\n            const resizeObserverInstance = new window.ResizeObserver((entries)=>{\n                if (!entries.length) return;\n                onResizeEvent();\n            });\n            resizeObserverInstance.observe(element, {\n                box: box\n            });\n            return ()=>{\n                if (element) resizeObserverInstance.unobserve(element);\n            };\n        }\n    }, [\n        ref,\n        box\n    ]);\n}\n\n\nexport {$9daab02d461809db$export$683480f191c0e3ea as useResizeObserver};\n//# sourceMappingURL=useResizeObserver.module.js.map\n","import {calculatePosition as $edcf132a9284368a$export$b3ceb0cbf1056d98, getRect as $edcf132a9284368a$export$4b834cebd9e5cebe} from \"./calculatePosition.mjs\";\nimport {useCloseOnScroll as $dd149f63282afbbf$export$18fc8428861184da} from \"./useCloseOnScroll.mjs\";\nimport {useState as $39EOa$useState, useRef as $39EOa$useRef, useEffect as $39EOa$useEffect, useCallback as $39EOa$useCallback} from \"react\";\nimport {useLayoutEffect as $39EOa$useLayoutEffect, useResizeObserver as $39EOa$useResizeObserver} from \"@react-aria/utils\";\nimport {useLocale as $39EOa$useLocale} from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\nlet $2a41e45df1593e64$var$visualViewport = typeof document !== 'undefined' ? window.visualViewport : null;\nfunction $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {\n    let { direction: direction } = (0, $39EOa$useLocale)();\n    let { arrowSize: arrowSize, targetRef: targetRef, overlayRef: overlayRef, arrowRef: arrowRef, scrollRef: scrollRef = overlayRef, placement: placement = 'bottom', containerPadding: containerPadding = 12, shouldFlip: shouldFlip = true, boundaryElement: boundaryElement = typeof document !== 'undefined' ? document.body : null, offset: offset = 0, crossOffset: crossOffset = 0, shouldUpdatePosition: shouldUpdatePosition = true, isOpen: isOpen = true, onClose: onClose, maxHeight: maxHeight, arrowBoundaryOffset: arrowBoundaryOffset = 0 } = props;\n    let [position, setPosition] = (0, $39EOa$useState)(null);\n    let deps = [\n        shouldUpdatePosition,\n        placement,\n        overlayRef.current,\n        targetRef.current,\n        arrowRef === null || arrowRef === void 0 ? void 0 : arrowRef.current,\n        scrollRef.current,\n        containerPadding,\n        shouldFlip,\n        boundaryElement,\n        offset,\n        crossOffset,\n        isOpen,\n        direction,\n        maxHeight,\n        arrowBoundaryOffset,\n        arrowSize\n    ];\n    // Note, the position freezing breaks if body sizes itself dynamicly with the visual viewport but that might\n    // just be a non-realistic use case\n    // Upon opening a overlay, record the current visual viewport scale so we can freeze the overlay styles\n    let lastScale = (0, $39EOa$useRef)($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale);\n    (0, $39EOa$useEffect)(()=>{\n        if (isOpen) lastScale.current = $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale;\n    }, [\n        isOpen\n    ]);\n    let updatePosition = (0, $39EOa$useCallback)(()=>{\n        if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !boundaryElement) return;\n        if (($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale) !== lastScale.current) return;\n        // Determine a scroll anchor based on the focused element.\n        // This stores the offset of the anchor element from the scroll container\n        // so it can be restored after repositioning. This way if the overlay height\n        // changes, the focused element appears to stay in the same position.\n        let anchor = null;\n        if (scrollRef.current && scrollRef.current.contains(document.activeElement)) {\n            var _document_activeElement;\n            let anchorRect = (_document_activeElement = document.activeElement) === null || _document_activeElement === void 0 ? void 0 : _document_activeElement.getBoundingClientRect();\n            let scrollRect = scrollRef.current.getBoundingClientRect();\n            var _anchorRect_top;\n            // Anchor from the top if the offset is in the top half of the scrollable element,\n            // otherwise anchor from the bottom.\n            anchor = {\n                type: 'top',\n                offset: ((_anchorRect_top = anchorRect === null || anchorRect === void 0 ? void 0 : anchorRect.top) !== null && _anchorRect_top !== void 0 ? _anchorRect_top : 0) - scrollRect.top\n            };\n            if (anchor.offset > scrollRect.height / 2) {\n                anchor.type = 'bottom';\n                var _anchorRect_bottom;\n                anchor.offset = ((_anchorRect_bottom = anchorRect === null || anchorRect === void 0 ? void 0 : anchorRect.bottom) !== null && _anchorRect_bottom !== void 0 ? _anchorRect_bottom : 0) - scrollRect.bottom;\n            }\n        }\n        // Always reset the overlay's previous max height if not defined by the user so that we can compensate for\n        // RAC collections populating after a second render and properly set a correct max height + positioning when it populates.\n        let overlay = overlayRef.current;\n        if (!maxHeight && overlayRef.current) {\n            var _window_visualViewport;\n            overlay.style.top = '0px';\n            overlay.style.bottom = '';\n            var _window_visualViewport_height;\n            overlay.style.maxHeight = ((_window_visualViewport_height = (_window_visualViewport = window.visualViewport) === null || _window_visualViewport === void 0 ? void 0 : _window_visualViewport.height) !== null && _window_visualViewport_height !== void 0 ? _window_visualViewport_height : window.innerHeight) + 'px';\n        }\n        let position = (0, $edcf132a9284368a$export$b3ceb0cbf1056d98)({\n            placement: $2a41e45df1593e64$var$translateRTL(placement, direction),\n            overlayNode: overlayRef.current,\n            targetNode: targetRef.current,\n            scrollNode: scrollRef.current || overlayRef.current,\n            padding: containerPadding,\n            shouldFlip: shouldFlip,\n            boundaryElement: boundaryElement,\n            offset: offset,\n            crossOffset: crossOffset,\n            maxHeight: maxHeight,\n            arrowSize: arrowSize !== null && arrowSize !== void 0 ? arrowSize : (arrowRef === null || arrowRef === void 0 ? void 0 : arrowRef.current) ? (0, $edcf132a9284368a$export$4b834cebd9e5cebe)(arrowRef.current, true).width : 0,\n            arrowBoundaryOffset: arrowBoundaryOffset\n        });\n        if (!position.position) return;\n        // Modify overlay styles directly so positioning happens immediately without the need of a second render\n        // This is so we don't have to delay autoFocus scrolling or delay applying preventScroll for popovers\n        overlay.style.top = '';\n        overlay.style.bottom = '';\n        overlay.style.left = '';\n        overlay.style.right = '';\n        Object.keys(position.position).forEach((key)=>overlay.style[key] = position.position[key] + 'px');\n        overlay.style.maxHeight = position.maxHeight != null ? position.maxHeight + 'px' : '';\n        // Restore scroll position relative to anchor element.\n        if (anchor && document.activeElement && scrollRef.current) {\n            let anchorRect = document.activeElement.getBoundingClientRect();\n            let scrollRect = scrollRef.current.getBoundingClientRect();\n            let newOffset = anchorRect[anchor.type] - scrollRect[anchor.type];\n            scrollRef.current.scrollTop += newOffset - anchor.offset;\n        }\n        // Trigger a set state for a second render anyway for arrow positioning\n        setPosition(position);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n    // Update position when anything changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0, $39EOa$useLayoutEffect)(updatePosition, deps);\n    // Update position on window resize\n    $2a41e45df1593e64$var$useResize(updatePosition);\n    // Update position when the overlay changes size (might need to flip).\n    (0, $39EOa$useResizeObserver)({\n        ref: overlayRef,\n        onResize: updatePosition\n    });\n    // Update position when the target changes size (might need to flip).\n    (0, $39EOa$useResizeObserver)({\n        ref: targetRef,\n        onResize: updatePosition\n    });\n    // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n    // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n    let isResizing = (0, $39EOa$useRef)(false);\n    (0, $39EOa$useLayoutEffect)(()=>{\n        let timeout;\n        let onResize = ()=>{\n            isResizing.current = true;\n            clearTimeout(timeout);\n            timeout = setTimeout(()=>{\n                isResizing.current = false;\n            }, 500);\n            updatePosition();\n        };\n        // Only reposition the overlay if a scroll event happens immediately as a result of resize (aka the virtual keyboard has appears)\n        // We don't want to reposition the overlay if the user has pinch zoomed in and is scrolling the viewport around.\n        let onScroll = ()=>{\n            if (isResizing.current) onResize();\n        };\n        $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener('resize', onResize);\n        $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener('scroll', onScroll);\n        return ()=>{\n            $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener('resize', onResize);\n            $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener('scroll', onScroll);\n        };\n    }, [\n        updatePosition\n    ]);\n    let close = (0, $39EOa$useCallback)(()=>{\n        if (!isResizing.current) onClose === null || onClose === void 0 ? void 0 : onClose();\n    }, [\n        onClose,\n        isResizing\n    ]);\n    // When scrolling a parent scrollable region of the trigger (other than the body),\n    // we hide the popover. Otherwise, its position would be incorrect.\n    (0, $dd149f63282afbbf$export$18fc8428861184da)({\n        triggerRef: targetRef,\n        isOpen: isOpen,\n        onClose: onClose && close\n    });\n    var _position_maxHeight, _position_placement, _position_triggerAnchorPoint;\n    return {\n        overlayProps: {\n            style: {\n                position: position ? 'absolute' : 'fixed',\n                top: !position ? 0 : undefined,\n                left: !position ? 0 : undefined,\n                zIndex: 100000,\n                ...position === null || position === void 0 ? void 0 : position.position,\n                maxHeight: (_position_maxHeight = position === null || position === void 0 ? void 0 : position.maxHeight) !== null && _position_maxHeight !== void 0 ? _position_maxHeight : '100vh'\n            }\n        },\n        placement: (_position_placement = position === null || position === void 0 ? void 0 : position.placement) !== null && _position_placement !== void 0 ? _position_placement : null,\n        triggerAnchorPoint: (_position_triggerAnchorPoint = position === null || position === void 0 ? void 0 : position.triggerAnchorPoint) !== null && _position_triggerAnchorPoint !== void 0 ? _position_triggerAnchorPoint : null,\n        arrowProps: {\n            'aria-hidden': 'true',\n            role: 'presentation',\n            style: {\n                left: position === null || position === void 0 ? void 0 : position.arrowOffsetLeft,\n                top: position === null || position === void 0 ? void 0 : position.arrowOffsetTop\n            }\n        },\n        updatePosition: updatePosition\n    };\n}\nfunction $2a41e45df1593e64$var$useResize(onResize) {\n    (0, $39EOa$useLayoutEffect)(()=>{\n        window.addEventListener('resize', onResize, false);\n        return ()=>{\n            window.removeEventListener('resize', onResize, false);\n        };\n    }, [\n        onResize\n    ]);\n}\nfunction $2a41e45df1593e64$var$translateRTL(position, direction) {\n    if (direction === 'rtl') return position.replace('start', 'right').replace('end', 'left');\n    return position.replace('start', 'left').replace('end', 'right');\n}\n\n\nexport {$2a41e45df1593e64$export$d39e1813b3bdd0e1 as useOverlayPosition};\n//# sourceMappingURL=useOverlayPosition.module.js.map\n","import {useLayoutEffect as $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c} from \"./useLayoutEffect.mjs\";\nimport {flushSync as $jJMAe$flushSync} from \"react-dom\";\nimport {useState as $jJMAe$useState, useCallback as $jJMAe$useCallback} from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $d3f049242431219c$export$6d3443f2c48bfc20(ref, isReady = true) {\n    let [isEntering, setEntering] = (0, $jJMAe$useState)(true);\n    let isAnimationReady = isEntering && isReady;\n    // There are two cases for entry animations:\n    // 1. CSS @keyframes. The `animation` property is set during the isEntering state, and it is removed after the animation finishes.\n    // 2. CSS transitions. The initial styles are applied during the isEntering state, and removed immediately, causing the transition to occur.\n    //\n    // In the second case, cancel any transitions that were triggered prior to the isEntering = false state (when the transition is supposed to start).\n    // This can happen when isReady starts as false (e.g. popovers prior to placement calculation).\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (isAnimationReady && ref.current && 'getAnimations' in ref.current) {\n            for (let animation of ref.current.getAnimations())if (animation instanceof CSSTransition) animation.cancel();\n        }\n    }, [\n        ref,\n        isAnimationReady\n    ]);\n    $d3f049242431219c$var$useAnimation(ref, isAnimationReady, (0, $jJMAe$useCallback)(()=>setEntering(false), []));\n    return isAnimationReady;\n}\nfunction $d3f049242431219c$export$45fda7c47f93fd48(ref, isOpen) {\n    let [exitState, setExitState] = (0, $jJMAe$useState)(isOpen ? 'open' : 'closed');\n    switch(exitState){\n        case 'open':\n            // If isOpen becomes false, set the state to exiting.\n            if (!isOpen) setExitState('exiting');\n            break;\n        case 'closed':\n        case 'exiting':\n            // If we are exiting and isOpen becomes true, the animation was interrupted.\n            // Reset the state to open.\n            if (isOpen) setExitState('open');\n            break;\n    }\n    let isExiting = exitState === 'exiting';\n    $d3f049242431219c$var$useAnimation(ref, isExiting, (0, $jJMAe$useCallback)(()=>{\n        // Set the state to closed, which will cause the element to be unmounted.\n        setExitState((state)=>state === 'exiting' ? 'closed' : state);\n    }, []));\n    return isExiting;\n}\nfunction $d3f049242431219c$var$useAnimation(ref, isActive, onEnd) {\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (isActive && ref.current) {\n            if (!('getAnimations' in ref.current)) {\n                // JSDOM\n                onEnd();\n                return;\n            }\n            let animations = ref.current.getAnimations();\n            if (animations.length === 0) {\n                onEnd();\n                return;\n            }\n            let canceled = false;\n            Promise.all(animations.map((a)=>a.finished)).then(()=>{\n                if (!canceled) (0, $jJMAe$flushSync)(()=>{\n                    onEnd();\n                });\n            }).catch(()=>{});\n            return ()=>{\n                canceled = true;\n            };\n        }\n    }, [\n        ref,\n        isActive,\n        onEnd\n    ]);\n}\n\n\nexport {$d3f049242431219c$export$6d3443f2c48bfc20 as useEnterAnimation, $d3f049242431219c$export$45fda7c47f93fd48 as useExitAnimation};\n//# sourceMappingURL=animation.module.js.map\n","import {useCallback as $hnMvi$useCallback} from \"react\";\nimport {useControlledState as $hnMvi$useControlledState} from \"@react-stately/utils\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, $hnMvi$useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, $hnMvi$useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, $hnMvi$useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, $hnMvi$useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n\n\nexport {$fc909762b330b746$export$61c6a8c84e605fb6 as useOverlayTriggerState};\n//# sourceMappingURL=useOverlayTriggerState.module.js.map\n"],"names":[],"mappings":"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","ignoreList":[2,3,4,5,6,7]}